Index: src/vec2.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>#include \"../include/vec2.h\"\n\ndouble vec2::dot(const vec2& oth) const \n{\n    return x * oth.x + y * oth.y;\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/vec2.cpp b/src/vec2.cpp
--- a/src/vec2.cpp	(revision 76f5930c41ef722bf237b8f4d4ba66c4ac9458dc)
+++ b/src/vec2.cpp	(date 1721050934848)
@@ -1,4 +1,4 @@
-#include "../include/vec2.h"
+#include <vec2.h>
 
 double vec2::dot(const vec2& oth) const 
 {
Index: src/chunk.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>#include <chunk.h>\n\nChunk::Chunk(NoiseGenerator& gen, const glm::dvec2& coords,\n        const glm::vec2& begin, float scale)\n    : m_scale { scale }\n    , m_begin_coords { begin }\n    , m_chunk_id { coords }\n{\n    generate_vertices(gen);\n    generate_normals();\n\n    // creating buffers\n\tglGenVertexArrays(1, &mesh_VAO);\n\tglGenBuffers(1, &mesh_VBO);\n\n\tglBindVertexArray(mesh_VAO);\n\tglBindBuffer(GL_ARRAY_BUFFER, mesh_VBO);\n\tglBufferData(GL_ARRAY_BUFFER, m_vertices.size() * sizeof(Vertex<float>), \n\t\t\tm_vertices.data(), GL_STATIC_DRAW);\n\n\tglVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void *)0);\n\tglEnableVertexAttribArray(0);\n\n\t// generating surface normal buffers\n    glGenBuffers(1, &normals_VBO);\n\n    glBindBuffer(GL_ARRAY_BUFFER, normals_VBO);\n    glBufferData(GL_ARRAY_BUFFER, sizeof(Vertex<float>) * m_normals.size(), \n            m_normals.data(), GL_STATIC_DRAW);\n\n    glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void *)0);\n    glEnableVertexAttribArray(1);\n    glBindVertexArray(0);\n}\n\nChunk& Chunk::operator=(Chunk&& rhs)\n{\n    m_vertices = std::exchange(rhs.m_vertices, std::vector<Vertex<float>> {});\n    m_normals = std::exchange(rhs.m_normals, std::vector<Vertex<float>> {}); \n\n    m_scale = std::exchange(rhs.m_scale, 0.0);\n    m_begin_coords = std::exchange(rhs.m_begin_coords, glm::vec2());\n    m_chunk_id = std::exchange(rhs.m_chunk_id, glm::dvec2());\n\n    mesh_VAO = std::exchange(rhs.mesh_VAO, 0);    \n    mesh_VBO = std::exchange(rhs.mesh_VBO, 0);\n    normals_VBO = std::exchange(rhs.normals_VBO, 0);\n\n    return *this;\n}\n\nstd::vector<Vertex<float>> Chunk::create_heightmap(NoiseGenerator& gen)\n{\n    // calculation of the vertex quantity\n    std::vector<Vertex<float>> heightmap(pow(CHUNK_SIDE + 1, 2) * 2);\n    \n    size_t vert_count = 0;\n    float z_pos = m_begin_coords[1];\n\n    for (size_t i = 0; i < CHUNK_SIDE + 1; ++i) {\n        float x_pos = m_begin_coords[0];\n        for (size_t j = 0; j < CHUNK_SIDE + 1; ++j) {\n            const auto mesh_x = (float)(j + CHUNK_SIDE * m_chunk_id[0]) / m_scale;  \n            const auto mesh_y = (float)(i + CHUNK_SIDE * m_chunk_id[1]) / m_scale;  \n\n            heightmap[vert_count++] = Vertex<float>(\n                x_pos, \n                util::fbm(gen, mesh_x, mesh_y) + 0.5,\n                z_pos);\n            x_pos += 0.1f;\n        }\n\n        z_pos += 0.1f;\n    }\n\n    return heightmap;\n}\n\nvoid Chunk::generate_vertices(NoiseGenerator& gen)\n{\n    const auto heightmap = create_heightmap(gen);\n\n    static const size_t add_values[] = { 0, CHUNK_SIDE, CHUNK_SIDE + 1, 0, CHUNK_SIDE + 1, 1};\n    size_t ind_count = 0;\n    for (size_t i = 0; i < CHUNK_SIDE; ++i) {\n        for (size_t j = 0; j < CHUNK_SIDE; ++j) {\n            for (size_t k = 0; k < sizeof(add_values) / sizeof(size_t); ++k) {\n                const auto base_index = i * CHUNK_SIDE + j;\n                m_vertices[ind_count++] = heightmap[base_index + add_values[k]];\n            }\n        }\n    }\n}\n\nvoid Chunk::generate_normals()\n{\n    size_t surf_norm_index = 0;\n    for (size_t i = 0; i < m_vertices.size(); i += 3) {\n        glm::vec3 normal = glm::normalize(glm::cross(\n            (glm::vec3)(m_vertices[i + 1] - m_vertices[i]), \n            (glm::vec3)(m_vertices[i + 2] - m_vertices[i])));\n\n        const Vertex vert(normal[0], normal[1], normal[2]);\n\n        m_normals[surf_norm_index++] = vert;\t\n        m_normals[surf_norm_index++] = vert;\t\n        m_normals[surf_norm_index++] = vert;\t\n    }\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/chunk.cpp b/src/chunk.cpp
--- a/src/chunk.cpp	(revision 76f5930c41ef722bf237b8f4d4ba66c4ac9458dc)
+++ b/src/chunk.cpp	(date 1721157619018)
@@ -5,20 +5,19 @@
     : m_scale { scale }
     , m_begin_coords { begin }
     , m_chunk_id { coords }
+    , m_vertices { generate_vertices(gen) }
+    , m_normals { generate_normals() }
 {
-    generate_vertices(gen);
-    generate_normals();
-
     // creating buffers
 	glGenVertexArrays(1, &mesh_VAO);
 	glGenBuffers(1, &mesh_VBO);
 
 	glBindVertexArray(mesh_VAO);
 	glBindBuffer(GL_ARRAY_BUFFER, mesh_VBO);
-	glBufferData(GL_ARRAY_BUFFER, m_vertices.size() * sizeof(Vertex<float>), 
+	glBufferData(GL_ARRAY_BUFFER, sizeof(Vertex<float>) * m_vertices.size(), 
 			m_vertices.data(), GL_STATIC_DRAW);
 
-	glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void *)0);
+	glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, sizeof(Vertex<float>), (void *)0);
 	glEnableVertexAttribArray(0);
 
 	// generating surface normal buffers
@@ -28,15 +27,15 @@
     glBufferData(GL_ARRAY_BUFFER, sizeof(Vertex<float>) * m_normals.size(), 
             m_normals.data(), GL_STATIC_DRAW);
 
-    glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void *)0);
+    glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, sizeof(Vertex<float>), (void *)0);
     glEnableVertexAttribArray(1);
     glBindVertexArray(0);
 }
 
 Chunk& Chunk::operator=(Chunk&& rhs)
 {
-    m_vertices = std::exchange(rhs.m_vertices, std::vector<Vertex<float>> {});
-    m_normals = std::exchange(rhs.m_normals, std::vector<Vertex<float>> {}); 
+    m_vertices = std::exchange(rhs.m_vertices, vector<Vertex<float>> {});
+    m_normals = std::exchange(rhs.m_normals, vector<Vertex<float>> {}); 
 
     m_scale = std::exchange(rhs.m_scale, 0.0);
     m_begin_coords = std::exchange(rhs.m_begin_coords, glm::vec2());
@@ -49,24 +48,25 @@
     return *this;
 }
 
-std::vector<Vertex<float>> Chunk::create_heightmap(NoiseGenerator& gen)
+vector<Vertex<float>> Chunk::create_heightmap(NoiseGenerator& gen)
 {
     // calculation of the vertex quantity
-    std::vector<Vertex<float>> heightmap(pow(CHUNK_SIDE + 1, 2) * 2);
+    vector<Vertex<float>> heightmap(pow(CHUNK_SIDE + 1, 2));
     
     size_t vert_count = 0;
     float z_pos = m_begin_coords[1];
 
-    for (size_t i = 0; i < CHUNK_SIDE + 1; ++i) {
+    for (size_t i = 0; i <= CHUNK_SIDE; ++i) {
         float x_pos = m_begin_coords[0];
-        for (size_t j = 0; j < CHUNK_SIDE + 1; ++j) {
-            const auto mesh_x = (float)(j + CHUNK_SIDE * m_chunk_id[0]) / m_scale;  
-            const auto mesh_y = (float)(i + CHUNK_SIDE * m_chunk_id[1]) / m_scale;  
+        for (size_t j = 0; j <= CHUNK_SIDE; ++j) {
+            const auto mesh_x = (float)(i + CHUNK_SIDE * m_chunk_id[1]) / m_scale;  
+            const auto mesh_y = (float)(j + CHUNK_SIDE * m_chunk_id[0]) / m_scale;  
 
             heightmap[vert_count++] = Vertex<float>(
                 x_pos, 
                 util::fbm(gen, mesh_x, mesh_y) + 0.5,
                 z_pos);
+
             x_pos += 0.1f;
         }
 
@@ -76,24 +76,30 @@
     return heightmap;
 }
 
-void Chunk::generate_vertices(NoiseGenerator& gen)
+vector<Vertex<float>> Chunk::generate_vertices(NoiseGenerator& gen)
 {
+    vector<Vertex<float>> vertices( CHUNK_SIZE * 6 );
     const auto heightmap = create_heightmap(gen);
 
-    static const size_t add_values[] = { 0, CHUNK_SIDE, CHUNK_SIDE + 1, 0, CHUNK_SIDE + 1, 1};
     size_t ind_count = 0;
+    static const size_t add_values[] = { 0, CHUNK_SIDE + 1, CHUNK_SIDE + 2, 0, CHUNK_SIDE + 2, 1};
+
     for (size_t i = 0; i < CHUNK_SIDE; ++i) {
         for (size_t j = 0; j < CHUNK_SIDE; ++j) {
             for (size_t k = 0; k < sizeof(add_values) / sizeof(size_t); ++k) {
-                const auto base_index = i * CHUNK_SIDE + j;
-                m_vertices[ind_count++] = heightmap[base_index + add_values[k]];
+                const auto base_index = i * ( CHUNK_SIDE + 1 )  + j;
+                vertices[ind_count++] = heightmap[base_index + add_values[k]];
             }
         }
     }
+
+    return vertices;
 }
 
-void Chunk::generate_normals()
+vector<Vertex<float>> Chunk::generate_normals()
 {
+    vector<Vertex<float>> normals( CHUNK_SIZE * 6 );
+    
     size_t surf_norm_index = 0;
     for (size_t i = 0; i < m_vertices.size(); i += 3) {
         glm::vec3 normal = glm::normalize(glm::cross(
@@ -102,8 +108,10 @@
 
         const Vertex vert(normal[0], normal[1], normal[2]);
 
-        m_normals[surf_norm_index++] = vert;	
-        m_normals[surf_norm_index++] = vert;	
-        m_normals[surf_norm_index++] = vert;	
+        normals[surf_norm_index++] = vert;	
+        normals[surf_norm_index++] = vert;	
+        normals[surf_norm_index++] = vert;	
     }
+
+    return normals;
 }
Index: include/terrain.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>#ifndef TERRAIN_H\n#define TERRAIN_H\n\n#include <glad.h>\n#include <GLFW/glfw3.h>\n#include <iostream>\n#include <vector>\n\n#include <noise_gen.h>\n#include <perlin.h>\n#include <shader.h>\n#include <cstdlib>\n#include <unistd.h>\n#include <vertex.h>\n#include <chunk.h>\n\nclass TerrainMesh {\n\npublic:\n    TerrainMesh(NoiseGenerator& gen, \n        std::size_t width = 100, std::size_t height = 100, double scale = 40.0);\n\npublic:\n    std::size_t get_chunks_width() const;\n    std::size_t get_chunks_height() const;\n\nprivate:\n    void generate_chunks() ;\n    \npublic:\n    NoiseGenerator& m_gen;\n\n    std::size_t m_width;\n    std::size_t m_height;\n\n    double m_scale;\n    const float m_tile_distance = 0.10;\n    const float m_x_beg = 0.0;\n    const float m_z_beg = 0.0;\n\n    std::vector<Chunk> m_chunks;\n};\n\n#endif /* TERRAIN_H */\n\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/include/terrain.h b/include/terrain.h
--- a/include/terrain.h	(revision 76f5930c41ef722bf237b8f4d4ba66c4ac9458dc)
+++ b/include/terrain.h	(date 1721051015772)
@@ -15,7 +15,6 @@
 #include <chunk.h>
 
 class TerrainMesh {
-
 public:
     TerrainMesh(NoiseGenerator& gen, 
         std::size_t width = 100, std::size_t height = 100, double scale = 40.0);
@@ -25,7 +24,7 @@
     std::size_t get_chunks_height() const;
 
 private:
-    void generate_chunks() ;
+    void generate_chunks();
     
 public:
     NoiseGenerator& m_gen;
@@ -34,7 +33,6 @@
     std::size_t m_height;
 
     double m_scale;
-    const float m_tile_distance = 0.10;
     const float m_x_beg = 0.0;
     const float m_z_beg = 0.0;
 
Index: src/terrain.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>#include <terrain.h>\n\nTerrainMesh::TerrainMesh(NoiseGenerator& gen, std::size_t width, std::size_t height, double scale) \n    : m_gen { gen }\n    , m_width { width + 1 }\n    , m_height { height + 1 }\n    , m_scale { scale }\n{\n\tgenerate_chunks();\n}\n\nvoid TerrainMesh::generate_chunks() \n{\n    const float d = m_tile_distance * static_cast<float>(CHUNK_SIDE);\n\n    for (std::size_t i = 0; i < m_width - 1; ++i) {\n        for (std::size_t j = 0; j < m_height - 1; ++j) {\n            const auto pos = glm::dvec2(i, j);\n            const auto offset = glm::vec2((float)i * d, (float)j * d);\n            m_chunks.push_back(Chunk( m_gen, pos, offset )); \n        }\n    }\n}\n\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/terrain.cpp b/src/terrain.cpp
--- a/src/terrain.cpp	(revision 76f5930c41ef722bf237b8f4d4ba66c4ac9458dc)
+++ b/src/terrain.cpp	(date 1721123678360)
@@ -2,8 +2,8 @@
 
 TerrainMesh::TerrainMesh(NoiseGenerator& gen, std::size_t width, std::size_t height, double scale) 
     : m_gen { gen }
-    , m_width { width + 1 }
-    , m_height { height + 1 }
+    , m_width { width }
+    , m_height { height }
     , m_scale { scale }
 {
 	generate_chunks();
@@ -11,10 +11,10 @@
 
 void TerrainMesh::generate_chunks() 
 {
-    const float d = m_tile_distance * static_cast<float>(CHUNK_SIDE);
+    const float d = 0.10 * static_cast<float>(CHUNK_SIDE);
 
-    for (std::size_t i = 0; i < m_width - 1; ++i) {
-        for (std::size_t j = 0; j < m_height - 1; ++j) {
+    for (std::size_t i = 0; i < m_width; ++i) {
+        for (std::size_t j = 0; j < m_height; ++j) {
             const auto pos = glm::dvec2(i, j);
             const auto offset = glm::vec2((float)i * d, (float)j * d);
             m_chunks.push_back(Chunk( m_gen, pos, offset )); 
Index: shaders/geometry.glsl
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>#version 330 core\n\nlayout (triangles) in;\nlayout (triangle_strip, max_vertices = 3) out;\n\nin vec3 frag_pos[];\n\nout vec3 norm;\nout vec3 frag;\n\nvoid main()\n{\n    vec3 a = frag_pos[1] - frag_pos[0];\n    vec3 b = frag_pos[2] - frag_pos[1];\n    norm = normalize(cross(a, b));\n\n    frag = vec3(\n        (frag_pos[0].x + frag_pos[1].x + frag_pos[2].x) / 3.0f, \n        (frag_pos[0].y + frag_pos[1].y + frag_pos[2].y) / 3.0f, \n        (frag_pos[0].z + frag_pos[1].z + frag_pos[2].z) / 3.0f\n    );\n\n    for (int i = 0; i < 3; ++i) {\n        gl_Position = gl_in[i].gl_Position;\n        EmitVertex();\n    }\n\n    EndPrimitive();\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/shaders/geometry.glsl b/shaders/geometry.glsl
--- a/shaders/geometry.glsl	(revision 76f5930c41ef722bf237b8f4d4ba66c4ac9458dc)
+++ b/shaders/geometry.glsl	(date 1721123620144)
@@ -11,15 +11,9 @@
 void main()
 {
     vec3 a = frag_pos[1] - frag_pos[0];
-    vec3 b = frag_pos[2] - frag_pos[1];
+    vec3 b = frag_pos[2] - frag_pos[0];
     norm = normalize(cross(a, b));
 
-    frag = vec3(
-        (frag_pos[0].x + frag_pos[1].x + frag_pos[2].x) / 3.0f, 
-        (frag_pos[0].y + frag_pos[1].y + frag_pos[2].y) / 3.0f, 
-        (frag_pos[0].z + frag_pos[1].z + frag_pos[2].z) / 3.0f
-    );
-
     for (int i = 0; i < 3; ++i) {
         gl_Position = gl_in[i].gl_Position;
         EmitVertex();
Index: .gitignore
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>build\nobjs\n.cache\n\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.gitignore b/.gitignore
--- a/.gitignore	(revision 76f5930c41ef722bf237b8f4d4ba66c4ac9458dc)
+++ b/.gitignore	(date 1721194565693)
@@ -1,4 +1,1045 @@
-build
-objs
-.cache
+##### Windows
+# Windows thumbnail cache files
+Thumbs.db
+Thumbs.db:encryptable
+ehthumbs.db
+ehthumbs_vista.db
+
+# Dump file
+*.stackdump
+
+# Folder config file
+[Dd]esktop.ini
+
+# Recycle Bin used on file shares
+$RECYCLE.BIN/
+
+# Windows Installer files
+*.cab
+*.msi
+*.msix
+*.msm
+*.msp
+
+# Windows shortcuts
+*.lnk
+
+##### Linux
+*~
+
+# temporary files which can be created if a process still has a handle open of a deleted file
+.fuse_hidden*
+
+# KDE directory preferences
+.directory
+
+# Linux trash folder which might appear on any partition or disk
+.Trash-*
+
+# .nfs files are created when an open file is removed but is still being accessed
+.nfs*
+
+##### MacOS
+# General
+.DS_Store
+.AppleDouble
+.LSOverride
+
+# Thumbnails
+._*
+
+# Files that might appear in the root of a volume
+.DocumentRevisions-V100
+.fseventsd
+.Spotlight-V100
+.TemporaryItems
+.Trashes
+.VolumeIcon.icns
+.com.apple.timemachine.donotpresent
+
+# Directories potentially created on remote AFP share
+.AppleDB
+.AppleDesktop
+Network Trash Folder
+Temporary Items
+.apdisk
+
+##### Android
+# Built application files
+*.apk
+*.ap_
+*.aab
+
+# Files for the ART/Dalvik VM
+*.dex
+
+# Java class files
+*.class
+
+# Generated files
+bin/
+gen/
+out/
+#  Uncomment the following line in case you need and you don't have the release build type files in your app
+# release/
+
+# Gradle files
+.gradle/
+build/
+
+# Local configuration file (sdk path, etc)
+local.properties
+
+# Proguard folder generated by Eclipse
+proguard/
+
+# Log Files
+*.log
+
+# Android Studio Navigation editor temp files
+.navigation/
+
+# Android Studio captures folder
+captures/
+
+# IntelliJ
+*.iml
+.idea/workspace.xml
+.idea/tasks.xml
+.idea/gradle.xml
+.idea/assetWizardSettings.xml
+.idea/dictionaries
+.idea/libraries
+# Android Studio 3 in .gitignore file.
+.idea/caches
+.idea/modules.xml
+# Comment next line if keeping position of elements in Navigation Editor is relevant for you
+.idea/navEditor.xml
+
+# Keystore files
+# Uncomment the following lines if you do not want to check your keystore files in.
+#*.jks
+#*.keystore
+
+# External native build folder generated in Android Studio 2.2 and later
+.externalNativeBuild
+
+# Google Services (e.g. APIs or Firebase)
+# google-services.json
+
+# Freeline
+freeline.py
+freeline/
+freeline_project_description.json
+
+# fastlane
+fastlane/report.xml
+fastlane/Preview.html
+fastlane/screenshots
+fastlane/test_output
+fastlane/readme.md
+
+# Version control
+vcs.xml
+
+# lint
+lint/intermediates/
+lint/generated/
+lint/outputs/
+lint/tmp/
+# lint/reports/
+
+##### Backup
+*.bak
+*.gho
+*.ori
+*.orig
+*.tmp
+
+##### GPG
+secring.*
+
+##### Dropbox
+# Dropbox settings and caches
+.dropbox
+.dropbox.attr
+.dropbox.cache
+
+##### SynopsysVCS
+# Waveform formats
+*.vcd
+*.vpd
+*.evcd
+*.fsdb
+
+# Default name of the simulation executable.  A different name can be
+# specified with this switch (the associated daidir database name is
+# also taken from here):  -o <path>/<filename>
+simv
+
+# Generated for Verilog and VHDL top configs
+simv.daidir/
+simv.db.dir/
+
+# Infrastructure necessary to co-simulate SystemC models with
+# Verilog/VHDL models.  An alternate directory may be specified with this
+# switch:  -Mdir=<directory_path>
+csrc/
+
+# Log file - the following switch allows to specify the file that will be
+# used to write all messages from simulation:  -l <filename>
+*.log
+
+# Coverage results (generated with urg) and database location.  The
+# following switch can also be used:  urg -dir <coverage_directory>.vdb
+simv.vdb/
+urgReport/
+
+# DVE and UCLI related files.
+DVEfiles/
+ucli.key
+
+# When the design is elaborated for DirectC, the following file is created
+# with declarations for C/C++ functions.
+vc_hdrs.h
+
+##### SVN
+.svn/
+
+##### Mercurial
+.hg/
+.hgignore
+.hgsigs
+.hgsub
+.hgsubstate
+.hgtags
+
+##### Bazaar
+.bzr/
+.bzrignore
+
+##### CVS
+/CVS/*
+**/CVS/*
+.cvsignore
+*/.cvsignore
+
+##### TortoiseGit
+# Project-level settings
+/.tgitconfig
+
+##### PuTTY
+# Private key
+*.ppk
+
+##### Vim
+# Swap
+[._]*.s[a-v][a-z]
+!*.svg  # comment out if you don't need vector files
+[._]*.sw[a-p]
+[._]s[a-rt-v][a-z]
+[._]ss[a-gi-z]
+[._]sw[a-p]
+
+# Session
+Session.vim
+Sessionx.vim
+
+# Temporary
+.netrwhist
+*~
+# Auto-generated tag files
+tags
+# Persistent undo
+[._]*.un~
+
+##### Emacs
+# -*- mode: gitignore; -*-
+*~
+\#*\#
+/.emacs.desktop
+/.emacs.desktop.lock
+*.elc
+auto-save-list
+tramp
+.\#*
+
+# Org-mode
+.org-id-locations
+*_archive
+
+# flymake-mode
+*_flymake.*
+
+# eshell files
+/eshell/history
+/eshell/lastdir
+
+# elpa packages
+/elpa/
+
+# reftex files
+*.rel
+
+# AUCTeX auto folder
+/auto/
+
+# cask packages
+.cask/
+dist/
+
+# Flycheck
+flycheck_*.el
+
+# server auth directory
+/server/
+
+# projectiles files
+.projectile
 
+# directory configuration
+.dir-locals.el
+
+# network security
+/network-security.data
+
+##### SublimeText
+# Cache files for Sublime Text
+*.tmlanguage.cache
+*.tmPreferences.cache
+*.stTheme.cache
+
+# Workspace files are user-specific
+*.sublime-workspace
+
+# Project files should be checked into the repository, unless a significant
+# proportion of contributors will probably not be using Sublime Text
+# *.sublime-project
+
+# SFTP configuration file
+sftp-config.json
+sftp-config-alt*.json
+
+# Package control specific files
+Package Control.last-run
+Package Control.ca-list
+Package Control.ca-bundle
+Package Control.system-ca-bundle
+Package Control.cache/
+Package Control.ca-certs/
+Package Control.merged-ca-bundle
+Package Control.user-ca-bundle
+oscrypto-ca-bundle.crt
+bh_unicode_properties.cache
+
+# Sublime-github package stores a github token in this file
+# https://packagecontrol.io/packages/sublime-github
+GitHub.sublime-settings
+
+##### Notepad++
+# Notepad++ backups #
+*.bak
+
+##### TextMate
+*.tmproj
+*.tmproject
+tmtags
+
+##### VisualStudioCode
+.vscode/*
+!.vscode/settings.json
+!.vscode/tasks.json
+!.vscode/launch.json
+!.vscode/extensions.json
+*.code-workspace
+
+# Local History for Visual Studio Code
+.history/
+
+##### NetBeans
+**/nbproject/private/
+**/nbproject/Makefile-*.mk
+**/nbproject/Package-*.bash
+build/
+nbbuild/
+dist/
+nbdist/
+.nb-gradle/
+
+##### JetBrains
+# Covers JetBrains IDEs: IntelliJ, RubyMine, PhpStorm, AppCode, PyCharm, CLion, Android Studio, WebStorm and Rider
+# Reference: https://intellij-support.jetbrains.com/hc/en-us/articles/206544839
+
+# User-specific stuff
+.idea/**/workspace.xml
+.idea/**/tasks.xml
+.idea/**/usage.statistics.xml
+.idea/**/dictionaries
+.idea/**/shelf
+
+# Generated files
+.idea/**/contentModel.xml
+
+# Sensitive or high-churn files
+.idea/**/dataSources/
+.idea/**/dataSources.ids
+.idea/**/dataSources.local.xml
+.idea/**/sqlDataSources.xml
+.idea/**/dynamic.xml
+.idea/**/uiDesigner.xml
+.idea/**/dbnavigator.xml
+
+# Gradle
+.idea/**/gradle.xml
+.idea/**/libraries
+
+# Gradle and Maven with auto-import
+# When using Gradle or Maven with auto-import, you should exclude module files,
+# since they will be recreated, and may cause churn.  Uncomment if using
+# auto-import.
+# .idea/artifacts
+# .idea/compiler.xml
+# .idea/jarRepositories.xml
+# .idea/modules.xml
+# .idea/*.iml
+# .idea/modules
+# *.iml
+# *.ipr
+
+# CMake
+cmake-build-*/
+
+# Mongo Explorer plugin
+.idea/**/mongoSettings.xml
+
+# File-based project format
+*.iws
+
+# IntelliJ
+out/
+
+# mpeltonen/sbt-idea plugin
+.idea_modules/
+
+# JIRA plugin
+atlassian-ide-plugin.xml
+
+# Cursive Clojure plugin
+.idea/replstate.xml
+
+# Crashlytics plugin (for Android Studio and IntelliJ)
+com_crashlytics_export_strings.xml
+crashlytics.properties
+crashlytics-build.properties
+fabric.properties
+
+# Editor-based Rest Client
+.idea/httpRequests
+
+# Android studio 3.1+ serialized cache file
+.idea/caches/build_file_checksums.ser
+
+##### Eclipse
+.metadata
+bin/
+tmp/
+*.tmp
+*.bak
+*.swp
+*~.nib
+local.properties
+.settings/
+.loadpath
+.recommenders
+
+# External tool builders
+.externalToolBuilders/
+
+# Locally stored "Eclipse launch configurations"
+*.launch
+
+# PyDev specific (Python IDE for Eclipse)
+*.pydevproject
+
+# CDT-specific (C/C++ Development Tooling)
+.cproject
+
+# CDT- autotools
+.autotools
+
+# Java annotation processor (APT)
+.factorypath
+
+# PDT-specific (PHP Development Tools)
+.buildpath
+
+# sbteclipse plugin
+.target
+
+# Tern plugin
+.tern-project
+
+# TeXlipse plugin
+.texlipse
+
+# STS (Spring Tool Suite)
+.springBeans
+
+# Code Recommenders
+.recommenders/
+
+# Annotation Processing
+.apt_generated/
+.apt_generated_test/
+
+# Scala IDE specific (Scala & Java development for Eclipse)
+.cache-main
+.scala_dependencies
+.worksheet
+
+# Uncomment this line if you wish to ignore the project description file.
+# Typically, this file would be tracked if it contains build/dependency configurations:
+#.project
+
+##### Qt
+# C++ objects and libs
+*.slo
+*.lo
+*.o
+*.a
+*.la
+*.lai
+*.so
+*.so.*
+*.dll
+*.dylib
+
+# Qt-es
+object_script.*.Release
+object_script.*.Debug
+*_plugin_import.cpp
+/.qmake.cache
+/.qmake.stash
+*.pro.user
+*.pro.user.*
+*.qbs.user
+*.qbs.user.*
+*.moc
+moc_*.cpp
+moc_*.h
+qrc_*.cpp
+ui_*.h
+*.qmlc
+*.jsc
+Makefile*
+*build-*
+*.qm
+*.prl
+
+# Qt unit tests
+target_wrapper.*
+
+# QtCreator
+*.autosave
+
+# QtCreator Qml
+*.qmlproject.user
+*.qmlproject.user.*
+
+# QtCreator CMake
+CMakeLists.txt.user*
+
+# QtCreator 4.8< compilation database 
+compile_commands.json
+
+# QtCreator local machine specific files for imported projects
+*creator.user*
+
+##### VisualStudio
+##### VisualStudio
+## Ignore Visual Studio temporary files, build results, and
+## files generated by popular Visual Studio add-ons.
+##
+## Get latest from https://github.com/github/gitignore/blob/master/VisualStudio.gitignore
+
+# User-specific files
+*.rsuser
+*.suo
+*.user
+*.userosscache
+*.sln.docstates
+
+# User-specific files (MonoDevelop/Xamarin Studio)
+*.userprefs
+
+# Mono auto generated files
+mono_crash.*
+
+# Build results
+[Dd]ebug/
+[Dd]ebugPublic/
+[Rr]elease/
+[Rr]eleases/
+x64/
+x86/
+[Ww][Ii][Nn]32/
+[Aa][Rr][Mm]/
+[Aa][Rr][Mm]64/
+bld/
+[Bb]in/
+[Oo]bj/
+[Ll]og/
+[Ll]ogs/
+
+# Visual Studio 2015/2017 cache/options directory
+.vs/
+# Uncomment if you have tasks that create the project's static files in wwwroot
+#wwwroot/
+
+# Visual Studio 2017 auto generated files
+Generated\ Files/
+
+# MSTest test Results
+[Tt]est[Rr]esult*/
+[Bb]uild[Ll]og.*
+
+# NUnit
+*.VisualState.xml
+TestResult.xml
+nunit-*.xml
+
+# Build Results of an ATL Project
+[Dd]ebugPS/
+[Rr]eleasePS/
+dlldata.c
+
+# Benchmark Results
+BenchmarkDotNet.Artifacts/
+
+# .NET Core
+project.lock.json
+project.fragment.lock.json
+artifacts/
+
+# ASP.NET Scaffolding
+ScaffoldingReadMe.txt
+
+# StyleCop
+StyleCopReport.xml
+
+# Files built by Visual Studio
+*_i.c
+*_p.c
+*_h.h
+*.ilk
+*.meta
+*.obj
+*.iobj
+*.pch
+*.pdb
+*.ipdb
+*.pgc
+*.pgd
+*.rsp
+*.sbr
+*.tlb
+*.tli
+*.tlh
+*.tmp
+*.tmp_proj
+*_wpftmp.csproj
+*.log
+*.vspscc
+*.vssscc
+.builds
+*.pidb
+*.svclog
+*.scc
+
+# Chutzpah Test files
+_Chutzpah*
+
+# Visual C++ cache files
+ipch/
+*.aps
+*.ncb
+*.opendb
+*.opensdf
+*.sdf
+*.cachefile
+*.VC.db
+*.VC.VC.opendb
+
+# Visual Studio profiler
+*.psess
+*.vsp
+*.vspx
+*.sap
+
+# Visual Studio Trace Files
+*.e2e
+
+# TFS 2012 Local Workspace
+$tf/
+
+# Guidance Automation Toolkit
+*.gpState
+
+# ReSharper is a .NET coding add-in
+_ReSharper*/
+*.[Rr]e[Ss]harper
+*.DotSettings.user
+
+# TeamCity is a build add-in
+_TeamCity*
+
+# DotCover is a Code Coverage Tool
+*.dotCover
+
+# AxoCover is a Code Coverage Tool
+.axoCover/*
+!.axoCover/settings.json
+
+# Coverlet is a free, cross platform Code Coverage Tool
+coverage*[.json, .xml, .info]
+
+# Visual Studio code coverage results
+*.coverage
+*.coveragexml
+
+# NCrunch
+_NCrunch_*
+.*crunch*.local.xml
+nCrunchTemp_*
+
+# MightyMoose
+*.mm.*
+AutoTest.Net/
+
+# Web workbench (sass)
+.sass-cache/
+
+# Installshield output folder
+[Ee]xpress/
+
+# DocProject is a documentation generator add-in
+DocProject/buildhelp/
+DocProject/Help/*.HxT
+DocProject/Help/*.HxC
+DocProject/Help/*.hhc
+DocProject/Help/*.hhk
+DocProject/Help/*.hhp
+DocProject/Help/Html2
+DocProject/Help/html
+
+# Click-Once directory
+publish/
+
+# Publish Web Output
+*.[Pp]ublish.xml
+*.azurePubxml
+# Note: Comment the next line if you want to checkin your web deploy settings,
+# but database connection strings (with potential passwords) will be unencrypted
+*.pubxml
+*.publishproj
+
+# Microsoft Azure Web App publish settings. Comment the next line if you want to
+# checkin your Azure Web App publish settings, but sensitive information contained
+# in these scripts will be unencrypted
+PublishScripts/
+
+# NuGet Packages
+*.nupkg
+# NuGet Symbol Packages
+*.snupkg
+# The packages folder can be ignored because of Package Restore
+**/[Pp]ackages/*
+# except build/, which is used as an MSBuild target.
+!**/[Pp]ackages/build/
+# Uncomment if necessary however generally it will be regenerated when needed
+#!**/[Pp]ackages/repositories.config
+# NuGet v3's project.json files produces more ignorable files
+*.nuget.props
+*.nuget.targets
+
+# Microsoft Azure Build Output
+csx/
+*.build.csdef
+
+# Microsoft Azure Emulator
+ecf/
+rcf/
+
+# Windows Store app package directories and files
+AppPackages/
+BundleArtifacts/
+Package.StoreAssociation.xml
+_pkginfo.txt
+*.appx
+*.appxbundle
+*.appxupload
+
+# Visual Studio cache files
+# files ending in .cache can be ignored
+*.[Cc]ache
+# but keep track of directories ending in .cache
+!?*.[Cc]ache/
+
+# Others
+ClientBin/
+~$*
+*~
+*.dbmdl
+*.dbproj.schemaview
+*.jfm
+*.pfx
+*.publishsettings
+orleans.codegen.cs
+
+# Including strong name files can present a security risk
+# (https://github.com/github/gitignore/pull/2483#issue-259490424)
+#*.snk
+
+# Since there are multiple workflows, uncomment next line to ignore bower_components
+# (https://github.com/github/gitignore/pull/1529#issuecomment-104372622)
+#bower_components/
+
+# RIA/Silverlight projects
+Generated_Code/
+
+# Backup & report files from converting an old project file
+# to a newer Visual Studio version. Backup files are not needed,
+# because we have git ;-)
+_UpgradeReport_Files/
+Backup*/
+UpgradeLog*.XML
+UpgradeLog*.htm
+ServiceFabricBackup/
+*.rptproj.bak
+
+# SQL Server files
+*.mdf
+*.ldf
+*.ndf
+
+# Business Intelligence projects
+*.rdl.data
+*.bim.layout
+*.bim_*.settings
+*.rptproj.rsuser
+*- [Bb]ackup.rdl
+*- [Bb]ackup ([0-9]).rdl
+*- [Bb]ackup ([0-9][0-9]).rdl
+
+# Microsoft Fakes
+FakesAssemblies/
+
+# GhostDoc plugin setting file
+*.GhostDoc.xml
+
+# Node.js Tools for Visual Studio
+.ntvs_analysis.dat
+node_modules/
+
+# Visual Studio 6 build log
+*.plg
+
+# Visual Studio 6 workspace options file
+*.opt
+
+# Visual Studio 6 auto-generated workspace file (contains which files were open etc.)
+*.vbw
+
+# Visual Studio LightSwitch build output
+**/*.HTMLClient/GeneratedArtifacts
+**/*.DesktopClient/GeneratedArtifacts
+**/*.DesktopClient/ModelManifest.xml
+**/*.Server/GeneratedArtifacts
+**/*.Server/ModelManifest.xml
+_Pvt_Extensions
+
+# Paket dependency manager
+.paket/paket.exe
+paket-files/
+
+# FAKE - F# Make
+.fake/
+
+# CodeRush personal settings
+.cr/personal
+
+# Python Tools for Visual Studio (PTVS)
+__pycache__/
+*.pyc
+
+# Cake - Uncomment if you are using it
+# tools/**
+# !tools/packages.config
+
+# Tabs Studio
+*.tss
+
+# Telerik's JustMock configuration file
+*.jmconfig
+
+# BizTalk build output
+*.btp.cs
+*.btm.cs
+*.odx.cs
+*.xsd.cs
+
+# OpenCover UI analysis results
+OpenCover/
+
+# Azure Stream Analytics local run output
+ASALocalRun/
+
+# MSBuild Binary and Structured Log
+*.binlog
+
+# NVidia Nsight GPU debugger configuration file
+*.nvuser
+
+# MFractors (Xamarin productivity tool) working folder
+.mfractor/
+
+# Local History for Visual Studio
+.localhistory/
+
+# BeatPulse healthcheck temp database
+healthchecksdb
+
+# Backup folder for Package Reference Convert tool in Visual Studio 2017
+MigrationBackup/
+
+# Ionide (cross platform F# VS Code tools) working folder
+.ionide/
+
+# Fody - auto-generated XML schema
+FodyWeavers.xsd
+
+##### Gradle
+.gradle
+**/build/
+!src/**/build/
+
+# Ignore Gradle GUI config
+gradle-app.setting
+
+# Avoid ignoring Gradle wrapper jar file (.jar files are usually ignored)
+!gradle-wrapper.jar
+
+# Cache of project
+.gradletasknamecache
+
+# # Work around https://youtrack.jetbrains.com/issue/IDEA-116898
+# gradle/wrapper/gradle-wrapper.properties
+
+##### CMake
+CMakeLists.txt.user
+CMakeCache.txt
+CMakeFiles
+CMakeScripts
+Testing
+Makefile
+cmake_install.cmake
+install_manifest.txt
+compile_commands.json
+CTestTestfile.cmake
+_deps
+
+##### C++
+# Prerequisites
+*.d
+
+# Compiled Object files
+*.slo
+*.lo
+*.o
+*.obj
+
+# Precompiled Headers
+*.gch
+*.pch
+
+# Compiled Dynamic libraries
+*.so
+*.dylib
+*.dll
+
+# Fortran module files
+*.mod
+*.smod
+
+# Compiled Static libraries
+*.lai
+*.la
+*.a
+*.lib
+
+# Executables
+*.exe
+*.out
+*.app
+
+# C/C++ binary extension file
+*.bin
+
+##### C
+# Prerequisites
+*.d
+
+# Object files
+*.o
+*.ko
+*.obj
+*.elf
+
+# Linker output
+*.ilk
+*.map
+*.exp
+
+# Precompiled Headers
+*.gch
+*.pch
+
+# Libraries
+*.lib
+*.a
+*.la
+*.lo
+
+# Shared objects (inc. Windows DLLs)
+*.dll
+*.so
+*.so.*
+*.dylib
+
+# Executables
+*.exe
+*.out
+*.app
+*.i*86
+*.x86_64
+*.hex
+
+# Debug files
+*.dSYM/
+*.su
+*.idb
+*.pdb
+
+# Kernel Module Compile Results
+*.mod*
+*.cmd
+.tmp_versions/
+modules.order
+Module.symvers
+Mkfile.old
+dkms.conf
+
+# Raspberry Pi Pico Object file
+*.uf2
+# Raspberry Pi Pico disassembler file
+*.dis
\ No newline at end of file
Index: include/chunk.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>#ifndef CHUNK_H\n#define CHUNK_H\n\n#include <vertex.h>\n#include <noise_gen.h>\n#include <utility.h>\n\n#include <glad.h>\n#include <glm/vec2.hpp>\n#include <glm/vec3.hpp>\n#include <glm/gtc/matrix_transform.hpp>\n#include <vector>\n#include <utility>\n\nconstexpr std::size_t CHUNK_SIDE = 16;\nconstexpr std::size_t CHUNK_SIZE = CHUNK_SIDE * CHUNK_SIDE;\n\nclass Chunk {\npublic:\n    Chunk(NoiseGenerator& gen, const glm::dvec2& coords, \n        const glm::vec2& begin = glm::vec2(0.0f), float scale = 40.0f);\n    \n    Chunk& operator=(Chunk&& rhs);\n    Chunk(const Chunk& rhs) = default;\n\npublic:\n    GLuint get_VAO() const { return mesh_VAO; }\n    GLuint get_VBO() const { return mesh_VBO; }\n\n    bool is_visible(const glm::vec3& camera_coords, \n            const glm::vec3& euler_angles) const;\n       \nprivate:\n    void generate_vertices(NoiseGenerator& gen);\n    void generate_normals();\n    std::vector<Vertex<float>> create_heightmap(NoiseGenerator& gen);\n\npublic:\n    std::vector<Vertex<float>> m_vertices { CHUNK_SIZE * 6 }; \n    std::vector<Vertex<float>> m_normals { CHUNK_SIZE * 6 };\n    \n    float m_scale = 40.0f;\n\n    glm::vec2 m_begin_coords;\n    glm::dvec2 m_chunk_id;\n\n    GLuint mesh_VAO, mesh_VBO;\n    GLuint normals_VBO;\n};\n\n#endif /* CHUNK_H */\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/include/chunk.h b/include/chunk.h
--- a/include/chunk.h	(revision 76f5930c41ef722bf237b8f4d4ba66c4ac9458dc)
+++ b/include/chunk.h	(date 1721117605386)
@@ -15,8 +15,11 @@
 constexpr std::size_t CHUNK_SIDE = 16;
 constexpr std::size_t CHUNK_SIZE = CHUNK_SIDE * CHUNK_SIDE;
 
+using std::vector;
+
 class Chunk {
 public:
+
     Chunk(NoiseGenerator& gen, const glm::dvec2& coords, 
         const glm::vec2& begin = glm::vec2(0.0f), float scale = 40.0f);
     
@@ -31,14 +34,11 @@
             const glm::vec3& euler_angles) const;
        
 private:
-    void generate_vertices(NoiseGenerator& gen);
-    void generate_normals();
-    std::vector<Vertex<float>> create_heightmap(NoiseGenerator& gen);
+    vector<Vertex<float>> generate_vertices(NoiseGenerator& gen);
+    vector<Vertex<float>> generate_normals();
+    vector<Vertex<float>> create_heightmap(NoiseGenerator& gen);
 
 public:
-    std::vector<Vertex<float>> m_vertices { CHUNK_SIZE * 6 }; 
-    std::vector<Vertex<float>> m_normals { CHUNK_SIZE * 6 };
-    
     float m_scale = 40.0f;
 
     glm::vec2 m_begin_coords;
@@ -46,6 +46,9 @@
 
     GLuint mesh_VAO, mesh_VBO;
     GLuint normals_VBO;
+
+    vector<Vertex<float>> m_vertices; 
+    vector<Vertex<float>> m_normals;
 };
 
 #endif /* CHUNK_H */
Index: src/perlin.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>#include <perlin.h>\n\nvoid PerlinNoise::fill_permutations()\n{\n    std::random_device rd;\n    std::mt19937 g(rd());\n    std::uniform_real_distribution<> dis(0.0, 100.0);\n\n    for (int i = 0; i < m_size; ++i) {\n        m_rand_grad[i] = vec2(sin(dis(g)), cos(dis(g)));\n        m_permutations[i] = i + 1;\n    }\n\n    std::shuffle(m_permutations.begin(), m_permutations.end(), g);\n    m_permutations.insert(m_permutations.end(), m_permutations.begin(), \n            m_permutations.end());\n}\n\ndouble PerlinNoise::get_value(double x, double y) \n{\n    uint32_t ix = std::floor(x);\n    uint32_t iy = std::floor(y);\n\n    double dx = x - ix;\n    double dy = y - iy;\n    \n    vec2 top_left  = get_gradient_vec(ix, iy);\n    vec2 top_right = get_gradient_vec(ix + 1, iy);\n    vec2 bot_left  = get_gradient_vec(ix, iy + 1);\n    vec2 bot_right = get_gradient_vec(ix + 1, iy + 1);\n\n    double d1, d2;\n    d1 = top_left.dot(vec2(dx, dy)); \n    d2 = top_right.dot(vec2(dx - 1.0, dy)); \n    double r1 = util::interpolate(d1, d2, dx); \n\n    d1 = bot_left.dot(vec2(dx, dy - 1.0)); \n    d2 = bot_right.dot(vec2(dx - 1.0, dy - 1.0)); \n    double r2 = util::interpolate(d1, d2, dx);\n\n    return util::interpolate(r1, r2, dy);\n}\n\nvec2 PerlinNoise::get_gradient_vec(int x, int y) const\n{\n    return m_rand_grad[(m_permutations[x % m_size] + y % m_size) % m_size];\n}   \n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/perlin.cpp b/src/perlin.cpp
--- a/src/perlin.cpp	(revision 76f5930c41ef722bf237b8f4d4ba66c4ac9458dc)
+++ b/src/perlin.cpp	(date 1721047014442)
@@ -6,7 +6,7 @@
     std::mt19937 g(rd());
     std::uniform_real_distribution<> dis(0.0, 100.0);
 
-    for (int i = 0; i < m_size; ++i) {
+    for (size_t i = 0; i < m_size; ++i) {
         m_rand_grad[i] = vec2(sin(dis(g)), cos(dis(g)));
         m_permutations[i] = i + 1;
     }
Index: src/main.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>#include <terrain.h> \n#include <perlin.h> \n#include <shader.h> \n#include <camera.h> \n\n#include <glm/glm.hpp> \n#include <glm/gtc/matrix_transform.hpp> \n#include <glm/gtc/type_ptr.hpp>\n\nconst int SCR_WIDTH = 800; const int SCR_HEIGHT = 800;\n\nCamera camera; float delta_time = 0.0f; float last_frame = 0.0f; bool \nfirst_mouse = true;\n\nfloat lastX = static_cast<float>(SCR_WIDTH) / 2.0f;\nfloat lastY = static_cast<float>(SCR_HEIGHT) / 2.0f;\n\nvoid process(GLFWwindow *window);\nvoid mouse_callback(GLFWwindow *window, double xPos, double yPos);\n\nvoid render_terrain(const TerrainMesh& mesh);\n\nint main()\n{\n    glfwInit();\n    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);\n    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);\n    glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);\n\n#ifdef __APPLE__\n    glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE);\n#endif \n\n    atexit(glfwTerminate);\n    \n    GLFWwindow *window = glfwCreateWindow(800, 600, \"transform\", NULL, NULL);\n    if (window == NULL) {\n        std::cerr << \"glfwCreateWindow\" << std::endl;\n        exit(1);\n    }\n\n    glfwMakeContextCurrent(window);\n    glfwSetCursorPosCallback(window, mouse_callback);    \n    glfwSetInputMode(window, GLFW_CURSOR, GLFW_CURSOR_DISABLED);\n\n    if (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress)) {\n        std::cout << \"Failed to initialize GLAD\" << std::endl;\n        exit(1);\n    }   \n\n    glEnable(GL_CULL_FACE);\n    glCullFace(GL_BACK);\n    glFrontFace(GL_CCW);\n\n    glEnable(GL_DEPTH_TEST);\n    glDepthFunc(GL_LESS);\n\n    glfwSwapInterval(0);\n\n    auto shader_res = Shader::create(\"../shaders/vert.glsl\", \"../shaders/frag.glsl\");\n    if (const auto *err_value = std::get_if<std::string>(&shader_res)) {\n        std::cerr << *err_value << std::endl;\n        exit(1);\n    }\n\n    auto shader = std::get<Shader>(shader_res);\n    PerlinNoise noise;\n    TerrainMesh mesh(noise, 4, 4);\n\n    const glm::vec3 target_color(0.0f, 0.39f, 0.1f);\n    const glm::vec3 light_position(0.0f, 4.0f, 0.0f);\n\n    int frames = 0;\n    float last = glfwGetTime();\n    while (!glfwWindowShouldClose(window)) {\n        process(window);\n\n        float current = static_cast<float>(glfwGetTime());\n        delta_time = current - last_frame;\n        last_frame = current;\n\n\n        frames++;\n        if (current - last >= 1.0f) {\n            printf(\"%lf ms\\n\", 1000.0 / double( frames) );\n            printf(\"%d fps\\n\",  frames );\n            frames = 0;\n            last += 1.0f;\n        }\n\n        glClearColor(0.0f, 0.0f, 1.0f, 1.0f);\n        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);\n\n        // for rendering in polygon mode\n        // glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);\n\n        // rendering \n        glm::mat4 model(1.f);\n        glm::mat4 view = camera.get_view_matrix();\n        glm::mat4 proj = glm::perspective(glm::radians(45.0f),  SCR_WIDTH / static_cast<float>(SCR_HEIGHT), 0.1f, 100.f);\n\n        shader.use();\n        \n        shader.set_matrix4(model, \"model\")\n            .set_matrix4(view, \"view\")\n            .set_matrix4(proj, \"proj\")\n            .set_float3(target_color, \"u_target_color\")\n            .set_float3(camera.get_position(), \"u_camera_location\")\n            .set_float3(light_position, \"u_light_location\")\n            .set_float3(glm::vec3(1.0f, 1.0f, 1.0f), \"u_light_color\");\n\n        render_terrain(mesh);\n\n\t\tglfwSwapBuffers(window);\n\t\tglfwPollEvents();    \n    }\n}\n\nvoid process(GLFWwindow *window) {\n    if (glfwGetKey(window, GLFW_KEY_ESCAPE) == GLFW_PRESS) \n        glfwSetWindowShouldClose(window, true); \n\n    if (glfwGetKey(window, GLFW_KEY_W) == GLFW_PRESS) \n        camera.process_keyboard(MoveDirection::Forward, delta_time); \n    if (glfwGetKey(window, GLFW_KEY_S) == GLFW_PRESS) \n        camera.process_keyboard(MoveDirection::Backward, delta_time); \n    if (glfwGetKey(window, GLFW_KEY_A) == GLFW_PRESS)\n        camera.process_keyboard(MoveDirection::Left, delta_time);\n    if (glfwGetKey(window, GLFW_KEY_D) == GLFW_PRESS)\n        camera.process_keyboard(MoveDirection::Right, delta_time);\n    if (glfwGetKey(window, GLFW_KEY_Q) == GLFW_PRESS)\n        camera.process_keyboard(MoveDirection::Up, delta_time);\n    if (glfwGetKey(window, GLFW_KEY_E) == GLFW_PRESS)\n        camera.process_keyboard(MoveDirection::Down, delta_time);\n}\n\nvoid mouse_callback(GLFWwindow *, double xPos, double yPos)\n{\n    float xpos = static_cast<float>(xPos);\n    float ypos = static_cast<float>(yPos);\n\n    if (first_mouse) {\n        lastX = xpos;\n        lastY = ypos;\n        first_mouse = false;\n    }\n\n    float xoffset = xpos - lastX;\n    float yoffset = lastY - ypos;\n\n    lastX = xpos;\n    lastY = ypos;\n\n    camera.process_mouse(xoffset, yoffset);\n}\n\nvoid render_terrain(const TerrainMesh& mesh)\n{\n    for (size_t i = 0; i < mesh.m_chunks.size(); ++i) {\n        glBindVertexArray(mesh.m_chunks[i].mesh_VAO);  \n\t\tglDrawArrays(GL_TRIANGLES, 0, mesh.m_chunks[i].m_vertices.size());\n    }    \n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main.cpp b/src/main.cpp
--- a/src/main.cpp	(revision 76f5930c41ef722bf237b8f4d4ba66c4ac9458dc)
+++ b/src/main.cpp	(date 1721158428626)
@@ -65,7 +65,7 @@
 
     auto shader = std::get<Shader>(shader_res);
     PerlinNoise noise;
-    TerrainMesh mesh(noise, 4, 4);
+    TerrainMesh mesh(noise, 4, 5);
 
     const glm::vec3 target_color(0.0f, 0.39f, 0.1f);
     const glm::vec3 light_position(0.0f, 4.0f, 0.0f);
@@ -79,7 +79,6 @@
         delta_time = current - last_frame;
         last_frame = current;
 
-
         frames++;
         if (current - last >= 1.0f) {
             printf("%lf ms\n", 1000.0 / double( frames) );
